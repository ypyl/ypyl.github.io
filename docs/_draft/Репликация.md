---
title: "Replication"
date: 2018-09-20
draft = true

tags: ["high-load"]
categories: ["learning"]
---
В этой главе мы изучили вопрос репликации. Репликация может служить нескольким
целям.

 Высокая доступность. Сохранение работоспособности системы в целом даже
в случае отказа одной из машин (или нескольких машин, или даже целого
ЦОДа).

 Работа в офлайн-режиме. Возможность продолжения работы приложения
в случае прерывания соединения с сетью.

 Задержка. Данные размещаются географически близко к пользователям, чтобы
те могли работать с ними быстрее.

 Масштабирование. Возможность обрабатывать бо' льшие объемы операций чтения,
чем способна обработать одна машина, с помощью выполнения операций
чтения на репликах.

Несмотря на кажущуюся простоту задачи — хранение копий одних и тех же данных
на нескольких машинах, — репликация оказывается весьма непростым делом. Она
требует тщательного обдумывания вопроса конкурентного доступа и всех возможных
сбоев, а также того, как справиться с их последствиями. Как минимум необходимо
что-то делать с недоступными узлами и разрывами сети (и это не говоря уже
о более коварных типах отказов, например незаметной порче данных вследствие
программных ошибок).

Мы обсудили три основных метода репликации.

 Репликация с одним ведущим узлом. Клиенты отправляют информацию обо всех
операциях записи одному узлу (ведущему), который отправляет поток событий
изменения данных другим репликам (ведомым узлам). Операции чтения могут
выполняться в любой реплике, но прочитанные из ведомых узлов данные могут
оказаться устаревшими.

 Репликация с несколькими ведущими узлами. Клиенты отправляют информацию
о каждой из операций записи одному из нескольких ведущих узлов, могущих эту
информацию принимать. Ведущие могут отправлять поток событий изменения
данных друг другу и любым ведомым.

 Репликация без ведущего узла. Клиенты отправляют информацию о каждой из
операций записи одному из нескольких узлов и читают из нескольких узлов параллельно,
чтобы обнаружить узлы с устаревшими данными и внести поправки.

У каждого из этих методов есть свои достоинства и недостатки. Репликация с одним
ведущим узлом широко распространена в силу своей простоты и отсутствия
надобности в разрешении конфликтов. Методы репликации с несколькими ведущими
узлами и без ведущего узла, возможно, более устойчивы к отказам узлов, разрывам
сети и резким скачкам времени задержки за счет усложнения и обеспечения
лишь очень слабых гарантий согласованности.

Репликация может быть синхронной или асинхронной; это очень сильно влияет
на поведение системы в случае сбоя. Хотя асинхронная репликация может выполняться
быстрее в случае нормальной работы системы, важно понимать, что
произойдет при росте задержки репликации и отказах серверов. В случае отказа
ведущего узла и возведения одного из ведомых узлов в ранг ведущего существует
вероятность потери недавно зафиксированных данных.

Мы рассмотрели некоторые необычные эффекты, вызываемые задержкой репликации,
и обсудили несколько моделей согласованности, полезных при решении
вопроса о требуемом поведении приложения в случае задержки репликации.

 Согласованность типа «чтение после записи». Пользователи должны всегда
видеть данные, которые они сами отправили в БД.

 Монотонное чтение. После того как пользователь увидел данные по состоянию
на какой-либо момент времени, он не должен позднее увидеть те же данные по
состоянию на более ранний момент времени.

 Согласованное префиксное чтение. Пользователи должны видеть данные в состоянии,
не нарушающем причинно-следственных связей: например, видеть
вопрос и ответ на него в правильном порядке.

Наконец, мы обсудили неотъемлемые для репликации с несколькими ведущими
узлами и без ведущего узла вопросы конкурентного доступа: поскольку в них допускается несколько конкурентных операций записи, вероятны конфликты.
Мы изучили алгоритм, который может использоваться в базах данных для выяснения,
произошла ли одна операция до другой, или они происходили конкурентно.
Мы также затронули методы разрешения конфликтов путем слияния конкурентных
обновлений.

В следующей главе мы продолжим рассмотрение распределенных по нескольким
машинам данных через призму эквивалента репликации: разбиения большого набора
данных на секции (partitions).