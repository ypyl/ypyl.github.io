---
layout: post
title: "Tinker: Loss Functions"
date: 2026-02-08

tags: tinker, llm, finetuning, qwen3-vl
categories: ai, programming
---

## Cross-Entropy: Measuring Prediction "Surprise"

```py
# The core mathematical implementation for classification
loss = -torch.log(predicted_probability_of_correct_class)
```

### The Core Logic

Cross-entropy measures the **divergence** between two probability distributions: the **True Label** () and the **Model Prediction** (). It quantifies how efficiently your model describes the reality of the data.

* **Low Cross-Entropy**: The model is "confident and correct." It assigns a high probability (close to 1.0) to the true class.
* **High Cross-Entropy**: The model is "surprised." It assigned a low probability to the outcome that actually occurred, resulting in a heavy penalty.

---

### Why this structure is used:

| Component | Logic | Result |
| --- | --- | --- |
| **Prediction ()** | Softmax output | Provides a differentiable probability for every class. |
| **True Label ()** | One-hot vector | Acts as a ground-truth anchor (Probability = 1 for the right answer). |
| **Negative Log** |  | Transforms probabilities into a loss scale where 0 is perfect. |

---

### In Plain English

Think of this as a **"Truth Meter" for Predictions**:

1. **The Goal**: You want the model to shout the right answer.
2. **The Reality**: The model whispers the right answer (low probability).
3. **The Consequence**: Cross-entropy is the volume of the "correction" the model receives. If it whispers the truth, you scream at it to be louder. If it shouts the truth, you barely say a word. It effectively measures how much "new information" the model needs to learn before it stops being surprised by the correct answer.

---

### The "Surprise" Fundamental

Think of it as a **Penalty for Uncertainty**:

1. **The Goal**: Maximize the probability of the correct token.
2. **The Penalty**: Because we use the negative logarithm, as the predicted probability  approaches 0, the loss  approaches infinity:



**Example Scenario (Target Class: "Cat"):**

* **Model A (Confident)**: Predicts "Cat" at **0.9**.
* Calculation:  (Small penalty).


* **Model B (Wrong)**: Predicts "Cat" at **0.1**.
* Calculation:  (Significant penalty).



### Why it Beats Mean Squared Error (MSE)

In classification, we don't care how "far" the wrong answers are from each other; we only care that the mass is on the correct answer. Cross-entropy provides **steeper gradients** (a more aggressive learning signal) when the model is very wrong, forcing faster convergence during the initial stages of training.


## Policy Gradient: Importance Sampling

```py
# The core ratio calculation in RL (like PPO)
prob_ratio = torch.exp(new_logprobs - old_logprobs)
loss = -(prob_ratio * advantages).mean()
```

### The Core Logic

Importance sampling is a mathematical correction layer that allows you to train a **Target Policy** () using data actually generated by a different **Sampling Policy** (). It bridges the gap between what the model *did* and what the model *is currently learning to do*.

* **The Mismatch**: In Reinforcement Learning, as soon as you update your model, the data you just collected (using the previous version) becomes "stale."
* **The Correction**: Instead of throwing that data away, you re-weight it. You ask: "How much more (or less) likely is my *new* model to take this action compared to my *old* model?"

---

### Why this structure is used:

| Component | Logic | Result |
| --- | --- | --- |
| **Ratio ()** |  | Scales the update based on policy divergence. |
| **Advantage ()** | Reward - Baseline | Tells the model if the action was actually good or bad. |
| **Product** |  | Re-weights the feedback to keep the gradient unbiased. |

---

### In Plain English

Think of this as **Learning from Old Game Tapes**:

1. **The Action**: You watch a video of yourself playing basketball last week (Old Policy). You made a great shot (Positive Advantage).
2. **The Change**: Today, you’ve changed your shooting form (New Policy).
3. **The Adjustment**: If your *new* form makes that shot much harder to take, the "lesson" from the video isn't as relevant anymore. Importance sampling **scales down** the lesson. If your new form makes that shot even easier, it **scales up** the lesson.

---

### The "Accounting" Fundamental

Think of it as **Adjusting for Exchange Rates**:

1. **The Sampling (Old Policy)**: You go to a casino in a different country (Old Policy) and win 100 credits (Advantage).
2. **The Learning (New Policy)**: You bring those credits home. You can't just say you have "100" at home; you must multiply by the exchange rate (The Ratio) to know their true value in your current economy.

**The Calculation Outcomes:**

* **Ratio > 1**: The new model is *more* likely to take that action than the old one. If the action was good, we double down on it even harder.
* **Ratio < 1**: The new model is *less* likely to take that action. Even if it was a "good" action, we dampen the update because the new model is already moving away from it.

### Why It Matters: Off-Policy Learning

Without this ratio, the model would be "learning from a ghost." It would treat actions taken by its former self as if it took them right now, leading to mathematical bias, unstable updates, and eventual collapse. Importance sampling keeps the math "honest" relative to the current parameters.

## Proximal Policy Optimization (PPO)

```py
# The core PPO "Clipping" mechanism
prob_ratio = torch.exp(new_logprobs - old_logprobs)
clipped_ratio = torch.clamp(prob_ratio, 1 - epsilon, 1 + epsilon)

# Take the minimum of the two to be conservative
loss = -torch.min(prob_ratio * advantages, clipped_ratio * advantages).mean()
```

### The Core Logic

PPO is the "safety rail" for Reinforcement Learning. Standard Policy Gradients are unstable because a single bad update can ruin a model's performance beyond recovery. PPO fixes this by **clipping** the update, ensuring the new policy doesn't stray too far from the old one in a single step.

* **The Ratio ()**: Measures how much the new policy deviates from the old one.
* **The Constraint**: If the ratio moves outside a safe range (typically ), PPO "clips" the value, removing the incentive to make even more drastic changes.
* **The Minimum**: By taking the `min()` of the clipped and unclipped objectives, PPO only allows the model to improve if the change is moderate, but punishes it immediately if the change is dangerously large.

---

### Why this structure is used:

| Component | Logic | Result |
| --- | --- | --- |
| **Probability Ratio** |  | Tracks the magnitude of the policy change. |
| **Clipping ()** | `clamp(ratio, 0.8, 1.2)` | Defines the "Trust Region" where we trust the data. |
| **PPO Objective** | `min(unclipped, clipped)` | Prevents "collapsing" the model with massive updates. |

---

### In Plain English

Think of PPO as a **Governor on a Racing Engine**:

1. **The Goal**: You want the car (model) to go faster (higher reward).
2. **The Risk**: If you floor the gas pedal too hard and the wheels spin out, you crash.
3. **The Fix**: PPO is a limiter on the pedal. It says: "I'll let you accelerate, but only by 20% at a time." Even if your data suggests that turning the wheel 180 degrees is a "great idea," PPO forces you to turn it in small, manageable increments. It prevents the model from "over-correcting" based on a single lucky or unlucky batch of data.

---

### The "Trust Region" Fundamental

Think of it as **Scientific Peer Review**:

1. **The Data**: You found a "miracle cure" (a high-advantage action).
2. **The Skepticism**: PPO says, "I believe you found something good, but I don't trust it enough to change my entire medical practice overnight."
3. **The Step**: It allows a small change toward the cure. Only after more successful trials (more training steps) will it continue to move in that direction.

**The Calculation Outcomes:**

* **Inside the Clip**: The model learns normally using Importance Sampling.
* **Outside the Clip**: The gradient becomes zero (flat). The model stops learning from that specific token because it has already changed "enough" for one update cycle.

### Why It Matters: Stability

Without PPO, RL training is famously "brittle"—one batch of noisy data can cause the model to forget everything it knows. PPO makes training stable enough that you can run it on standard hardware without a PhD in hyperparameter tuning. It is the industry standard for RLHF (Reinforcement Learning from Human Feedback).


## Clipped Importance Sampling Policy Optimization (CISPO)

```py
# The core CISPO weighting mechanism
prob_ratio = torch.exp(new_logprobs - old_logprobs)
# Clip the ratio and detach it from the gradient graph
weight = torch.clamp(prob_ratio, 1 - epsilon, 1 + epsilon).detach()

# Use the static weight to scale the standard policy gradient
loss = -(weight * new_logprobs * advantages).sum()
```

### The Core Logic

CISPO is a variation of policy optimization that decouples the **importance weight** from the **gradient calculation**. While PPO clips the objective itself, CISPO clips the *coefficient* (the ratio) and treats it as a constant during the update.

* **Detached Weighting**: By using `.detach()`, the clipped ratio acts as a fixed multiplier. The model doesn't try to "optimize the ratio"; it only optimizes the log-probabilities scaled by how much it trusts that specific data point.
* **The Constraint**: Like PPO, it uses  thresholds to identify when a sample is too far outside the sampling distribution.
* **Gradient Directness**: It scales the standard REINFORCE-style gradient () by a bounded importance weight, preventing extreme gradient spikes.

---

### Why this structure is used:

| Component | Logic | Result |
| --- | --- | --- |
| **Clipped Ratio** | `clamp(p/q, 0.8, 1.2)` | Caps the maximum influence of any single token update. |
| **`.detach()`** | Stop-gradient | Ensures the ratio is treated as a static weight, not a function. |
| **** | Raw Log-Prob | Maintains a direct gradient path for the learner policy. |

---

### In Plain English

Think of CISPO as **Volume Control for a Coach**:

1. **The Feedback**: You are practicing a skill, and a coach is giving you feedback (Advantage).
2. **The PPO Method**: PPO changes the *message* itself—if the coach screams too loud, PPO muffles the actual words.
3. **The CISPO Method**: CISPO leaves the coach's message alone but puts a **limiter on the volume knob**. If the coach gets too excited (the ratio is too high), CISPO just holds the volume at "10" so you don't get deafened. You still hear the full, clear instruction (), just at a safe, capped intensity.

---

### The "Fixed Multiplier" Fundamental

Think of it as **Commission Capping**:

1. **Standard RL**: A salesperson gets a commission directly proportional to the sale size (). If they get one massive "whale" of a sale, they might retire and stop working (the model collapses).
2. **CISPO**: You tell the salesperson: "I'll pay you based on your performance, but I'm capping the multiplier at 1.2x." This keeps the incentive structure **linear and predictable** instead of exponential.

**The Calculation Outcomes:**

* **Inside the Clip**: CISPO behaves like standard importance sampling, providing unbiased updates.
* **Outside the Clip**: The update is "throttled." The model still moves in the right direction, but it ignores the magnitude of the divergence, treating it as a capped constant.

### Why It Matters: Gradients vs. Objectives

In some complex architectures, PPO’s `min()` operation can create "dead zones" or "jagged" loss landscapes where gradients disappear abruptly. CISPO provides a **smoother gradient signal** because the `log p` term is always active; only its importance weight is restricted. This can lead to more consistent behavior in large-scale language model training.

## Direct Reward Optimization (DRO)

```py
# The core DRO implementation with quadratic penalty
log_ratio = target_logprobs - sampling_logprobs
quadratic_penalty = 0.5 * beta * (log_ratio ** 2)

# Objective combines reward maximization with divergence cost
loss = -(target_logprobs * advantages - quadratic_penalty).sum()
```

### The Core Logic

DRO is an off-policy reinforcement learning method that replaces hard clipping (like PPO) with a **soft, quadratic penalty**. It treats the distance between the new policy and the old policy as a "cost" that must be balanced against the "profit" of the rewards.

* **The Log-Ratio**: Instead of a raw probability ratio, DRO looks at the difference in log-probabilities ().
* **Quadratic Constraint**: The penalty grows as the *square* of the distance. Small deviations are barely penalized, but large deviations become exponentially expensive.
* **The Beta ()**: A hyperparameter that controls how "stiff" the constraint is. A higher  forces the model to stay extremely close to the original sampling distribution.

---

### Why this structure is used:

| Component | Logic | Result |
| --- | --- | --- |
| **Log-Prob Growth** |  | Standard drive to increase the probability of good actions. |
| **Quadratic Term** |  | Measures the magnitude of the policy shift. |
| ** Coefficient** | Strength multiplier | Balances exploration (reward) vs. stability (penalty). |

---

### In Plain English

Think of DRO as **Training with an Elastic Tether**:

1. **The Goal**: You want the model to move toward the "gold" (Advantage).
2. **The Constraint**: The model is attached to its starting point (Sampling Policy) by a heavy rubber band.
3. **The Result**: The model can move toward the gold, but the further it stretches the rubber band, the harder the band pulls back. This creates a natural "equilibrium" where the model only makes big moves if the reward is massive enough to justify the "stretch."

---

### The "Cost of Change" Fundamental

Think of it as **Corporate Rebranding**:

1. **The Update**: A company wants to change its logo and strategy to increase profits (Advantage).
2. **The Cost**: Every change has an internal cost (Quadratic Penalty)—reprinting materials, retraining staff, and confusing customers.
3. **The Decision**: If the projected profit is small but the change is radical, DRO says "No." If the profit is huge, DRO allows the change, but "taxes" the update based on how radical it is.

### Why It Matters: Mathematical Consistency

Unlike PPO, which "clips" gradients to zero (creating flat spots in the math), DRO provides **smooth, continuous gradients** everywhere. This makes it mathematically more elegant for offline RL (learning from static datasets) because it treats the sampling distribution as a prior that shouldn't be abandoned without strong evidence. It effectively acts as a dynamic KL-divergence constraint.
